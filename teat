-- Brainrot ESP (standalone, event-driven, low overhead)
-- Toggle: F6, Unload: Shift+F6

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")

-- ===================== Config =====================
local CFG = {
	RootCandidates = {"Plots", "Plot", "Animals", "Pets"}, -- erster Treffer wird benutzt, sonst workspace

	-- Labels: wie heißt die TextLabel mit Geld/s?
	LabelNameAny = {"generation", "persecond", "geldprosekunde", "gps"},  -- case-insensitive

	-- Overhead für Namenssuche (optional)
	BillboardName = "AnimalOverhead", -- case-insensitive; wenn vorhanden, wird bevorzugt
	MaxBillboardDistance = 10000,

	ShowNameAbove = true,        -- Name oberhalb vom Geld/s anzeigen
	ShowBeam = true,             -- Linie vom Spieler zum Top-Target
	BeamColor = Color3.fromRGB(255, 0, 0),
	BeamWidth = 0.24,
	BeamTransparency = 0,

	HotkeyToggle = Enum.KeyCode.F6,   -- F6 toggeln, Shift+F6 entladen

	HighlightColor = Color3.fromRGB(255,255,255),
	OutlineTransparency = 0,
	FillTransparency = 1,

	TextColor = Color3.fromRGB(255,255,255),
	TextStrokeColor = Color3.fromRGB(0,0,0),
	TextStrokeTransparency = 0,
	ShowSuffix = " /s",

	-- Kandidaten für Namens-Label im Overhead
	NameLabelCandidates = {"name","title","animalname","display","username"},
}
-- ==================================================

local LocalPlayer = Players.LocalPlayer

-- Root finden
local ROOT = workspace
for _,name in ipairs(CFG.RootCandidates) do
	local c = workspace:FindFirstChild(name)
	if c then ROOT = c break end
end

local enabled = true
local alive = true

-- Instances
local highlight = Instance.new("Highlight")
highlight.Name = "BrainrotESP_Highlight"
highlight.FillTransparency = CFG.FillTransparency
highlight.OutlineTransparency = CFG.OutlineTransparency
highlight.OutlineColor = CFG.HighlightColor
highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
highlight.Enabled = false
highlight.Parent = workspace

local billboardHolder = Instance.new("BillboardGui")
billboardHolder.Name = "BrainrotESP_Label"
billboardHolder.AlwaysOnTop = true
billboardHolder.Size = UDim2.new(0,260,0,80)
billboardHolder.StudsOffset = Vector3.new(0,3.5,0)
billboardHolder.MaxDistance = CFG.MaxBillboardDistance
billboardHolder.Enabled = false
billboardHolder.Parent = LocalPlayer:WaitForChild("PlayerGui")

local textLabel = Instance.new("TextLabel")
textLabel.BackgroundTransparency = 1
textLabel.Size = UDim2.new(1,0,1,0)
textLabel.TextScaled = true
textLabel.Font = Enum.Font.SourceSansBold
textLabel.TextColor3 = CFG.TextColor
textLabel.TextStrokeColor3 = CFG.TextStrokeColor
textLabel.TextStrokeTransparency = CFG.TextStrokeTransparency
textLabel.TextXAlignment = Enum.TextXAlignment.Center
textLabel.TextYAlignment = Enum.TextYAlignment.Center
textLabel.RichText = true
textLabel.Text = ""
textLabel.Parent = billboardHolder

-- Beam (Linie)
local a0, a1, beam

-- State
local espTracked = {}   -- [Model] = {label=TextLabel, value=number, overhead=BillboardGui?, connText, connLblAnc, connModelAnc}
local labelToModel = {} -- [TextLabel] = Model
local currentTopModel = nil
local currentTopOverhead = nil
local connAdded, connRemoving

-- Utils
local function lower(s) return tostring(s or ""):lower() end

local function firstBasePart(model)
	if not model then return end
	if model.PrimaryPart then return model.PrimaryPart end
	for _,d in ipairs(model:GetDescendants()) do
		if d:IsA("BasePart") then return d end
	end
end

local function tryFindOverheadForModel(model)
	if not model then return nil end
	-- bevorzugt Billboard mit passendem Namen
	for _,d in ipairs(model:GetDescendants()) do
		if d:IsA("BillboardGui") and lower(d.Name) == lower(CFG.BillboardName) then
			return d
		end
	end
	-- ansonsten irgendein Billboard
	for _,d in ipairs(model:GetDescendants()) do
		if d:IsA("BillboardGui") then
			return d
		end
	end
	return nil
end

local function ensureBeamObjects()
	if not CFG.ShowBeam then return end
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local hrp = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 10)
	if not hrp then return end

	-- A0 auf HRP
	if a0 then
		if not a0.Parent or not a0:IsDescendantOf(character) then
			pcall(function() a0:Destroy() end)
			a0 = nil
		end
	end
	if not a0 then
		a0 = Instance.new("Attachment")
		a0.Name = "BrainrotESP_A0"
	end
	a0.Parent = hrp

	-- A1 frei halten (wird dynamisch an Target-Part geparentet)
	if a1 and a1.Parent and not a1.Parent:IsA("BasePart") then
		pcall(function() a1:Destroy() end)
		a1 = nil
	end
	if not a1 then
		a1 = Instance.new("Attachment")
		a1.Name = "BrainrotESP_A1"
	end

	if not beam or not beam.Parent then
		beam = Instance.new("Beam")
		beam.Name = "BrainrotESP_Beam"
		beam.Segments = 10
		beam.Width0 = CFG.BeamWidth or 0.24
		beam.Width1 = CFG.BeamWidth or 0.24
		beam.Transparency = NumberSequence.new(CFG.BeamTransparency or 0) -- 0 = voll sichtbar
		beam.Color = ColorSequence.new(CFG.BeamColor or Color3.fromRGB(255, 0, 0))
		beam.LightInfluence = 0
		beam.Attachment0 = a0
		beam.Attachment1 = a1
		beam.Enabled = false
		beam.Parent = workspace -- robust gegen Character-Respawn
	else
		beam.Attachment0 = a0
		beam.Attachment1 = a1
	end
end

local function setBeamTarget(part)
	if not CFG.ShowBeam then return end
	ensureBeamObjects()
	if not beam then return end
	if enabled and part and part:IsA("BasePart") and a0 and a0.Parent then
		a1.Parent = part
		beam.Enabled = true
	else
		beam.Enabled = false
	end
end

LocalPlayer.CharacterAdded:Connect(function()
	task.defer(function()
		if CFG.ShowBeam then
			ensureBeamObjects()
			if beam then beam.Enabled = false end
		end
	end)
end)

LocalPlayer.CharacterRemoving:Connect(function()
	if beam then beam.Enabled = false end
end)

local function smartTonum(numStr)
	if not numStr or numStr == "" then return nil end
	local hasComma = numStr:find(",")
	local hasDot = numStr:find("%.")
	if hasComma and hasDot then
		-- Heuristik: US "1,234.56" vs EU "1.234,56"
		if numStr:find(",%d%d%d") and numStr:find("%.%d%d") then
			numStr = numStr:gsub(",", "")
		elseif numStr:find("%.%d%d%d") and numStr:find(",%d%d") then
			numStr = numStr:gsub("%.", ""):gsub(",", ".")
		else
			numStr = numStr:gsub(",", "")
		end
	else
		numStr = numStr:gsub(",", ".")
	end
	return tonumber(numStr)
end

local function parseNumberWithSuffix(text)
	if not text then return nil end
	local s = tostring(text):lower()
	s = s:gsub("[%s\194\160]+"," ")
	s = s:gsub("[€$£¥₽₩]", "")
	s = s:gsub("per%s*second",""):gsub("pro%s*sekunde",""):gsub("per%s*sekunde","")
	s = s:gsub("/%s*sec",""):gsub("/%s*s","")
	-- nimm letztes Vorkommen von Zahl + optionaler Suffix
	local num, suf = s:match("([%-%d%.,]+)%s*([%a]*)%s*$")
	if not num then return nil end
	local base = smartTonum(num)
	if not base then return nil end
	local map = {
		k=1e3, tsd=1e3, thousand=1e3, tausend=1e3,
		m=1e6, mio=1e6, million=1e6, millionen=1e6,
		b=1e9, bn=1e9, mrd=1e9, milliarde=1e9, milliarden=1e9,
		t=1e12, tn=1e12, bio=1e12, billion=1e12, billionen=1e12,
		qa=1e15, qd=1e15, brd=1e15, billiarde=1e15, billiarden=1e15,
		qn=1e18, qi=1e18, tr=1e18, tri=1e18, trillion=1e18, trillionen=1e18,
		sx=1e21, sp=1e24, oc=1e27, no=1e30, de=1e33,
	}
	return base * (map[suf] or 1)
end

local function shortFormat(n)
	if not n then return "?" end
	local sign = n < 0 and "-" or ""
	n = math.abs(n)
	local units = {"","K","M","B","T","Qa","Qi","Sx","Sp","Oc","No","De"}
	local i = 1
	while n >= 1000 and i < #units do
		n = n / 1000
		i = i + 1
	end
	if i == 1 then
		return sign .. tostring(math.floor(n+0.5))
	else
		return string.format("%s%.2f %s", sign, n, units[i])
	end
end

local function findModelAndOverhead(label)
	local bb = label:FindFirstAncestorWhichIsA("BillboardGui")
	local m = label:FindFirstAncestorOfClass("Model") or (bb and bb:FindFirstAncestorOfClass("Model"))
	return m, bb
end

local function getAdorneeFor(model, overhead)
	if overhead and overhead.Adornee and overhead.Adornee:IsA("BasePart") then
		return overhead.Adornee
	end
	return firstBasePart(model)
end

local function resolveName(model, overhead)
	if not CFG.ShowNameAbove then
		return nil
	end
	-- bevorzugte Namenslabels im Overhead
	if overhead then
		for _,cand in ipairs(CFG.NameLabelCandidates) do
			for _,d in ipairs(overhead:GetDescendants()) do
				if d:IsA("TextLabel") and lower(d.Name) == lower(cand) then
					local t = tostring(d.Text or "")
					if #t > 0 then return t end
				end
			end
		end
		-- heuristisch: Label mit den meisten Buchstaben, das nicht wie "/s" o. ä. aussieht
		local bestTxt, bestScore = nil, -1
		for _,d in ipairs(overhead:GetDescendants()) do
			if d:IsA("TextLabel") then
				local t = tostring(d.Text or "")
				local letters = t:gsub("[%W%d_]+","")
				local score = #letters
				if score > bestScore and not lower(t):find("/s") then
					bestScore = score; bestTxt = t
				end
			end
		end
		if bestTxt and bestScore > 0 then return bestTxt end
	end
	return model and model.Name or "?"
end

local function setBillboard(adornee, nameText, value)
	billboardHolder.Adornee = adornee
	billboardHolder.Enabled = (billboardHolder.Adornee ~= nil)
	if not billboardHolder.Enabled then return end

	if CFG.ShowNameAbove and nameText and #nameText > 0 then
		textLabel.Text = string.format("<b>%s</b>\n%s%s",
			nameText,
			shortFormat(value or 0),
			CFG.ShowSuffix or ""
		)
	else
		textLabel.Text = shortFormat(value or 0) .. (CFG.ShowSuffix or "")
	end
end

local function setESP(model, value, overhead)
	if not enabled then
		currentTopModel = nil
		highlight.Enabled = false
		billboardHolder.Enabled = false
		setBeamTarget(nil)
		return
	end

	if not model or not model.Parent then
		currentTopModel = nil
		highlight.Enabled = false
		billboardHolder.Enabled = false
		setBeamTarget(nil)
		return
	end

	if currentTopModel ~= model then
		currentTopModel = model
		currentTopOverhead = overhead
		highlight.Adornee = model
		highlight.Enabled = true
	end

	local adornee = getAdorneeFor(model, overhead)
	setBillboard(adornee, resolveName(model, overhead), value)
	setBeamTarget(adornee)
end

local function updateTop()
	local bestModel, bestValue, bestOverhead = nil, -math.huge, nil
	for m, d in pairs(espTracked) do
		if m and m.Parent and d.label and d.label.Parent and d.value then
			if d.value > bestValue then
				bestModel, bestValue, bestOverhead = m, d.value, d.overhead
			end
		end
	end
	if bestModel then setESP(bestModel, bestValue, bestOverhead) else setESP(nil,nil,nil) end
end

local function deregister(model)
	local d = espTracked[model]
	if not d then return end
	if d.connText then d.connText:Disconnect() end
	if d.connLblAnc then d.connLblAnc:Disconnect() end
	if d.connModelAnc then d.connModelAnc:Disconnect() end
	labelToModel[d.label] = nil
	espTracked[model] = nil
end

local function isTargetLabel(inst)
	if not inst:IsA("TextLabel") then return false end
	local nm = lower(inst.Name)
	for _,cand in ipairs(CFG.LabelNameAny) do
		if nm == lower(cand) then return true end
	end
	-- Fallback: erkenne durch Textinhalt (/s, pro sekunde, per sekunde)
	local t = lower(inst.Text or "")
	if t:find("/s") or t:find("prosekunde") or t:find("persekunde") or t:find("per second") then
		return true
	end
	return false
end

local function registerLabel(label)
	if not alive then return end
	if not isTargetLabel(label) then return end

	local model, overhead = findModelAndOverhead(label)
	if not model then return end
	overhead = overhead or tryFindOverheadForModel(model)
	if labelToModel[label] then return end

	-- Wenn bereits ein Mapping für dieses Model existiert, ersetzen
	if espTracked[model] then deregister(model) end

	local data = {
		label = label,
		value = parseNumberWithSuffix(label.Text),
		overhead = overhead,
	}

	data.connText = label:GetPropertyChangedSignal("Text"):Connect(function()
		data.value = parseNumberWithSuffix(label.Text)
		if enabled then
			if currentTopModel == model then
				setBillboard(getAdorneeFor(model, data.overhead), resolveName(model, data.overhead), data.value)
			end
			updateTop()
		end
	end)
	data.connLblAnc = label.AncestryChanged:Connect(function()
		if not label:IsDescendantOf(ROOT) then
			deregister(model)
			if enabled then updateTop() end
		end
	end)
	data.connModelAnc = model.AncestryChanged:Connect(function()
		if not model:IsDescendantOf(ROOT) then
			deregister(model)
			if enabled then updateTop() end
		end
	end)

	espTracked[model] = data
	labelToModel[label] = model
	if enabled then updateTop() end
end

-- Start: initiale Registrierung
for _,d in ipairs(ROOT:GetDescendants()) do
	if isTargetLabel(d) then registerLabel(d) end
end

-- Live hooks
connAdded = ROOT.DescendantAdded:Connect(function(inst)
	if not alive then return end
	if isTargetLabel(inst) then registerLabel(inst) end
end)

connRemoving = ROOT.DescendantRemoving:Connect(function(inst)
	if not alive then return end
	if labelToModel[inst] then
		local m = labelToModel[inst]
		deregister(m)
		if enabled then updateTop() end
	elseif inst:IsA("Model") and espTracked[inst] then
		deregister(inst)
		if enabled then updateTop() end
	end
end)

-- Hotkeys: F6 toggeln, Shift+F6 unload
UIS.InputBegan:Connect(function(input, gp)
	if gp or not alive then return end
	if input.KeyCode == CFG.HotkeyToggle then
		local shiftDown = UIS:IsKeyDown(Enum.KeyCode.LeftShift) or UIS:IsKeyDown(Enum.KeyCode.RightShift)
		if shiftDown then
			-- unload
			alive = false
			enabled = false
			if connAdded then connAdded:Disconnect() end
			if connRemoving then connRemoving:Disconnect() end
			for m,_ in pairs(espTracked) do deregister(m) end
			espTracked = {}; labelToModel = {}
			if beam then beam:Destroy() end
			if a0 then a0:Destroy() end
			if a1 then a1:Destroy() end
			highlight:Destroy()
			billboardHolder:Destroy()
		else
			enabled = not enabled
			if not enabled then
				highlight.Enabled = false
				billboardHolder.Enabled = false
				setBeamTarget(nil)
			else
				updateTop()
			end
		end
	end
end)

-- Final safety: update once after short delay
task.delay(0.2, function()
	if alive and enabled then updateTop() end
end)
