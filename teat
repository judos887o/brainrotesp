-- Brainrot ESP (robust, autostart-safe, correct /s only)
-- Toggle: F6, Unload: Shift+F6

-- Warte, bis das Spiel wirklich geladen ist (damit du schon im Ladebildschirm executen kannst)
pcall(function()
	if not game:IsLoaded() then
		game.Loaded:Wait()
	end
end)

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local WORLD = workspace

-- ===================== Config =====================
local CFG = {
	-- Ordner, unter dem die Plots liegen (bei dir: "Plots")
	RootCandidates = {"Plots"},

	-- Geld/s-Label (Name oder Textinhalt)
	LabelNameAny = {"generation"},  -- case-insensitive

	MaxBillboardDistance = 10000,

	-- Anzeige
	ShowNameAbove = true,              -- Name oberhalb vom Geld/s anzeigen
	ShowOwnerIfNoName = true,          -- wenn kein explizites Namenslabel, nimm Plot-Owner (sofern vorhanden)
	HideNameIfUnknown = true,          -- wenn kein Name/Owner gefunden -> Name-Zeile ausblenden

	-- Beam (Linie)
	ShowBeam = true,
	BeamColor = Color3.fromRGB(255, 0, 0),
	BeamWidth = 0.24,
	BeamTransparency = 0,

	HotkeyToggle = Enum.KeyCode.F6,   -- F6 toggeln, Shift+F6 entladen

	HighlightColor = Color3.fromRGB(255,255,255),
	OutlineTransparency = 0,
	FillTransparency = 1,

	TextColor = Color3.fromRGB(255,255,255),
	TextStrokeColor = Color3.fromRGB(0,0,0),
	TextStrokeTransparency = 0,
	ShowSuffix = " /s",

	-- Wo könnte ein echter Name stehen?
	NameLabelCandidates = {"name","title","animalname","displayname","petname"},
	-- Owner-Infos
	OwnerValueCandidates = {"Owner","PlotOwner","TycoonOwner"},
	OwnerIdCandidates    = {"OwnerId","UserId"},
	-- Optional: Name via StringValue/Attribut am Plot
	NameValueCandidates = {"Name","DisplayName","AnimalName","PetName","Title","Brainrot","Type","Kind"},

	-- Wie oft Name “nachladen” (falls Owner erst später repliziert), in Sekunden
	NameRefreshInterval = 0.5,
}
-- ==================================================

local LocalPlayer = Players.LocalPlayer

-- Helpers
local function lower(s) return tostring(s or ""):lower() end

local ROOT_NAME_SET = {}
for _,n in ipairs(CFG.RootCandidates) do ROOT_NAME_SET[lower(n)] = true end
local function isCandidateRoot(inst)
	return inst and ROOT_NAME_SET[lower(inst.Name or "")]
end

-- Finde den Plot-Knoten: der nächstgelegene Vorfahre, dessen Parent ein RootCandidate ist (z. B. "Plots")
local function findPlotRootDynamic(inst)
	local cur = inst
	while cur and cur.Parent do
		if isCandidateRoot(cur.Parent) then
			return cur
		end
		cur = cur.Parent
	end
	return nil
end

local function firstBasePart(model)
	if not model then return end
	if model.PrimaryPart then return model.PrimaryPart end
	for _,d in ipairs(model:GetDescendants()) do
		if d:IsA("BasePart") then return d end
	end
end

-- UI
local billboardHolder = Instance.new("BillboardGui")
billboardHolder.Name = "BrainrotESP_Label"
billboardHolder.AlwaysOnTop = true
billboardHolder.Size = UDim2.new(0,260,0,80)
billboardHolder.StudsOffset = Vector3.new(0,3.5,0)
billboardHolder.MaxDistance = CFG.MaxBillboardDistance
billboardHolder.Enabled = false
billboardHolder.Parent = LocalPlayer:WaitForChild("PlayerGui")

local textLabel = Instance.new("TextLabel")
textLabel.BackgroundTransparency = 1
textLabel.Size = UDim2.new(1,0,1,0)
textLabel.TextScaled = true
textLabel.Font = Enum.Font.SourceSansBold
textLabel.TextColor3 = CFG.TextColor
textLabel.TextStrokeColor3 = CFG.TextStrokeColor
textLabel.TextStrokeTransparency = CFG.TextStrokeTransparency
textLabel.TextXAlignment = Enum.TextXAlignment.Center
textLabel.TextYAlignment = Enum.TextYAlignment.Center
textLabel.RichText = true
textLabel.Text = ""
textLabel.Parent = billboardHolder

local highlight = Instance.new("Highlight")
highlight.Name = "BrainrotESP_Highlight"
highlight.FillTransparency = CFG.FillTransparency
highlight.OutlineTransparency = CFG.OutlineTransparency
highlight.OutlineColor = CFG.HighlightColor
highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
highlight.Enabled = false
highlight.Parent = WORLD

-- Beam/Anchor
local a0 -- Attachment auf HumanoidRootPart
local anchorPart -- permanenter, unsichtbarer Part im Workspace
local a1 -- Attachment auf anchorPart
local beam
local beamUpdateConn
local beamTargetPart

-- State
local enabled = true
local alive = true

local espTracked = {}   -- [Model] = {label=TextLabel, value=number, overhead=BillboardGui?, connText, connLblAnc, connModelAnc}
local labelToModel = {} -- [TextLabel] = Model
local currentTopModel = nil
local currentTopOverhead = nil
local nameRefreshAccum = 0
local nameRefreshConn

-- Boot helpers
local function ensureCharacterAttachment()
	local character = LocalPlayer.Character
	if not character then return end
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	if not a0 or not a0.Parent or a0.Parent ~= hrp then
		if a0 then pcall(function() a0:Destroy() end) end
		a0 = Instance.new("Attachment")
		a0.Name = "BrainrotESP_A0"
		a0.Parent = hrp
	end
end

local function ensureBeamObjects()
	if not CFG.ShowBeam then return end

	ensureCharacterAttachment()

	-- Anchor-Part bleibt im Workspace
	if not anchorPart or not anchorPart.Parent then
		anchorPart = Instance.new("Part")
		anchorPart.Name = "BrainrotESP_TargetAnchor"
		anchorPart.Size = Vector3.new(0.2, 0.2, 0.2)
		anchorPart.Transparency = 1
		anchorPart.Anchored = true
		anchorPart.CanCollide = false
		anchorPart.CanQuery = false
		anchorPart.CanTouch = false
		anchorPart.Locked = true
		anchorPart.Parent = WORLD
	end

	if not a1 or not a1.Parent then
		a1 = Instance.new("Attachment")
		a1.Name = "BrainrotESP_A1"
		a1.Parent = anchorPart
	end

	if not beam or not beam.Parent then
		beam = Instance.new("Beam")
		beam.Name = "BrainrotESP_Beam"
		beam.Segments = 10
		beam.Width0 = CFG.BeamWidth or 0.24
		beam.Width1 = CFG.BeamWidth or 0.24
		beam.Transparency = NumberSequence.new(CFG.BeamTransparency or 0)
		beam.Color = ColorSequence.new(CFG.BeamColor or Color3.fromRGB(255, 0, 0))
		beam.LightInfluence = 0
		beam.Enabled = false
		beam.Attachment0 = a0
		beam.Attachment1 = a1
		beam.Parent = WORLD
	else
		beam.Attachment0 = a0
		beam.Attachment1 = a1
	end
end

local function startBeamFollowLoop()
	if beamUpdateConn then return end
	beamUpdateConn = RunService.RenderStepped:Connect(function()
		if not beam or not enabled or not CFG.ShowBeam then return end
		if beamTargetPart and beamTargetPart.Parent then
			local cf = (beamTargetPart.CFrame or CFrame.new(beamTargetPart.Position))
			anchorPart.CFrame = cf
			beam.Enabled = true
		else
			beam.Enabled = false
		end
	end)
end

local function stopBeamFollowLoop()
	if beamUpdateConn then
		beamUpdateConn:Disconnect()
		beamUpdateConn = nil
	end
	if beam then beam.Enabled = false end
end

local function setBeamTarget(part)
	if not CFG.ShowBeam then return end
	ensureBeamObjects()
	beamTargetPart = part
	if enabled and part then
		startBeamFollowLoop()
	else
		stopBeamFollowLoop()
	end
end

LocalPlayer.CharacterAdded:Connect(function()
	task.defer(function()
		ensureCharacterAttachment()
		ensureBeamObjects()
		if beam then beam.Enabled = false end
	end)
end)

LocalPlayer.CharacterRemoving:Connect(function()
	stopBeamFollowLoop()
	if beam then beam.Enabled = false end
end)

-- ============ Zahlen-/Suffix-Parsing (bevorzugt '/s') ============
local function smartTonum(numStr)
	if not numStr or numStr == "" then return nil end
	local hasComma = numStr:find(",")
	local hasDot = numStr:find("%.")
	if hasComma and hasDot then
		if numStr:find(",%d%d%d") and numStr:find("%.%d%d") then
			numStr = numStr:gsub(",", "")
		elseif numStr:find("%.%d%d%d") and numStr:find(",%d%d") then
			numStr = numStr:gsub("%.", ""):gsub(",", ".")
		else
			numStr = numStr:gsub(",", "")
		end
	else
		numStr = numStr:gsub(",", ".")
	end
	return tonumber(numStr)
end

local SUFFIX_MAP = {
	k=1e3, tsd=1e3, thousand=1e3, tausend=1e3,
	m=1e6, mio=1e6, million=1e6, millionen=1e6,
	b=1e9, bn=1e9, mrd=1e9, milliarde=1e9, milliarden=1e9,
	t=1e12, tn=1e12, bio=1e12, billion=1e12, billionen=1e12,
	qa=1e15, qd=1e15, brd=1e15, billiarde=1e15, billiarden=1e15,
	qn=1e18, qi=1e18, tr=1e18, tri=1e18, trillion=1e18, trillionen=1e18,
	sx=1e21, sp=1e24, oc=1e27, no=1e30, de=1e33,
}

local function applySuffix(numStr, suf)
	local base = smartTonum(numStr)
	if not base then return nil end
	local mul = SUFFIX_MAP[lower(suf or "")] or 1
	return base * mul
end

-- NUR den Wert mit '/s' nehmen; erst wenn keiner vorhanden ist, nichts (verhindert "100M" statt "300K/s")
local function parsePerSecond(text)
	if not text then return nil end
	local s = tostring(text)
	s = s:gsub("[%s\194\160]+"," ")
	s = s:gsub("[$€£¥₽₩]", "")
	local sLower = lower(s)

	-- 1) <num><suf>/s
	local val
	for num, suf in sLower:gmatch("([%-%d%.,]+)%s*([%a]*)%s*/%s*s") do
		val = applySuffix(num, suf) or val
	end
	if val then return val end

	-- 2) <num><suf> per second | per sekunde | pro sekunde
	for num, suf in sLower:gmatch("([%-%d%.,]+)%s*([%a]*)%s*per%s*second") do
		val = applySuffix(num, suf) or val
	end
	for num, suf in sLower:gmatch("([%-%d%.,]+)%s*([%a]*)%s*per%s*sekunde") do
		val = applySuffix(num, suf) or val
	end
	for num, suf in sLower:gmatch("([%-%d%.,]+)%s*([%a]*)%s*pro%s*sekunde") do
		val = applySuffix(num, suf) or val
	end
	return val
end

local function shortFormat(n)
	if not n then return "?" end
	local sign = n < 0 and "-" or ""
	n = math.abs(n)
	local units = {"","K","M","B","T","Qa","Qi","Sx","Sp","Oc","No","De"}
	local i = 1
	while n >= 1000 and i < #units do
		n = n / 1000
		i = i + 1
	end
	if i == 1 then
		return sign .. tostring(math.floor(n+0.5))
	else
		return string.format("%s%.2f %s", sign, n, units[i])
	end
end

-- Zielmodell + Overhead finden (AnimalOverhead hängt unter Spawn.Attachment)
local function findModelAndOverhead(label)
	local bb = label:FindFirstAncestorWhichIsA("BillboardGui")
	local m = label:FindFirstAncestorOfClass("Model")
	return m, bb
end

-- Adornee: nimm den Spawn-Part (Parent des Attachment), sonst BasePart des Models
local function getAdorneeFor(model, overhead)
	if overhead and overhead.Parent and overhead.Parent:IsA("Attachment") then
		local parent = overhead.Parent.Parent
		if parent and parent:IsA("BasePart") then
			return parent
		end
	end
	return firstBasePart(model)
end

-- Hilfs-Suche in Descendants
local function findDescendantByNames(container, classes, names)
	if not container then return nil end
	local nameSet = {}
	for _,n in ipairs(names) do nameSet[lower(n)] = true end
	for _,d in ipairs(container:GetDescendants()) do
		for _,cls in ipairs(classes) do
			if d:IsA(cls) and nameSet[lower(d.Name)] then
				return d
			end
		end
	end
	return nil
end

-- Nur echte Namens-Labels zulassen, Cash/Income/Offline ignorieren
local function getNameFromOverhead(overhead)
	if not overhead then return nil end
	local cand = {}
	local wanted = {}
	for _,n in ipairs(CFG.NameLabelCandidates) do wanted[lower(n)] = true end

	for _,d in ipairs(overhead:GetDescendants()) do
		if d:IsA("TextLabel") and wanted[lower(d.Name)] then
			local t = tostring(d.Text or "")
			if #t > 0 then
				local tl = lower(t)
				if not (tl:find("cash") or tl:find("coins") or tl:find("money") or tl:find("income")
					or tl:find("offline") or tl:find("online") or tl:find("/%s*s")
					or tl:find("per%s*second") or tl:find("pro%s*sekunde") or tl:find("[%$€£¥]")) then
					table.insert(cand, t)
				end
			end
		end
	end
	if #cand > 0 then
		table.sort(cand, function(a,b) return #a > #b end)
		return cand[1]
	end
	return nil
end

local function getOwnerName(plotRoot)
	if not plotRoot then return nil end
	local ownerObj = findDescendantByNames(plotRoot, {"ObjectValue"}, CFG.OwnerValueCandidates)
	if ownerObj and ownerObj.Value and ownerObj.Value:IsA("Player") then
		return ownerObj.Value.DisplayName or ownerObj.Value.Name
	end
	for _,idName in ipairs(CFG.OwnerIdCandidates) do
		local idVal = plotRoot:FindFirstChild(idName, true)
		if idVal and idVal:IsA("IntValue") then
			local ok, nameOrErr = pcall(function()
				return Players:GetNameFromUserIdAsync(idVal.Value)
			end)
			if ok and nameOrErr and #nameOrErr > 0 then
				return nameOrErr
			end
		end
	end
	return nil
end

local function getNameFromPlotData(plotRoot)
	if not plotRoot then return nil end
	local strV = findDescendantByNames(plotRoot, {"StringValue"}, CFG.NameValueCandidates)
	if strV and strV.Value and #strV.Value > 0 then
		return strV.Value
	end
	for _,attr in ipairs(CFG.NameValueCandidates) do
		local v = plotRoot:GetAttribute(attr)
		if v and tostring(v) ~= "" then
			return tostring(v)
		end
	end
	return nil
end

-- Namens-Resolver (nur echte Quellen)
local function resolveName(model, overhead)
	if not CFG.ShowNameAbove then return nil end

	local nameText = getNameFromOverhead(overhead)
	if nameText and #nameText > 0 then
		return nameText
	end

	local plotRoot = findPlotRootDynamic(model or overhead)
	if CFG.ShowOwnerIfNoName then
		local ownerName = getOwnerName(plotRoot)
		if ownerName and #ownerName > 0 then
			return ownerName
		end
	end

	local plotName = getNameFromPlotData(plotRoot)
	if plotName and #plotName > 0 then
		return plotName
	end

	if CFG.HideNameIfUnknown then
		return nil
	end

	return (model and model.Name) or nil
end

local function setBillboard(adornee, nameText, value)
	billboardHolder.Adornee = adornee
	billboardHolder.Enabled = (billboardHolder.Adornee ~= nil)
	if not billboardHolder.Enabled then return end

	if CFG.ShowNameAbove and nameText and #nameText > 0 then
		textLabel.Text = string.format("<b>%s</b>\n%s%s",
			nameText,
			(value ~= nil and shortFormat(value) or "?"),
			CFG.ShowSuffix or ""
		)
	else
		local vtxt = (value ~= nil and shortFormat(value) or "?")
		textLabel.Text = vtxt .. (CFG.ShowSuffix or "")
	end
end

-- ESP core
local function setESP(model, value, overhead)
	if not enabled then
		currentTopModel = nil
		highlight.Enabled = false
		billboardHolder.Enabled = false
		setBeamTarget(nil)
		return
	end

	if not model or not model.Parent then
		currentTopModel = nil
		highlight.Enabled = false
		billboardHolder.Enabled = false
		setBeamTarget(nil)
		return
	end

	if currentTopModel ~= model then
		currentTopModel = model
		currentTopOverhead = overhead
		highlight.Adornee = model
		highlight.Enabled = true
	end

	local adornee = getAdorneeFor(model, overhead)
	setBillboard(adornee, resolveName(model, overhead), value)
	setBeamTarget(adornee)
end

local function updateTop()
	local bestModel, bestValue, bestOverhead = nil, -math.huge, nil
	for m, d in pairs(espTracked) do
		if m and m.Parent and d.label and d.label.Parent and (d.value ~= nil) then
			if d.value > bestValue then
				bestModel, bestValue, bestOverhead = m, d.value, d.overhead
			end
		end
	end
	if bestModel then setESP(bestModel, bestValue, bestOverhead) else setESP(nil,nil,nil) end
end

local function deregister(model)
	local d = espTracked[model]
	if not d then return end
	if d.connText then d.connText:Disconnect() end
	if d.connLblAnc then d.connLblAnc:Disconnect() end
	if d.connModelAnc then d.connModelAnc:Disconnect() end
	labelToModel[d.label] = nil
	espTracked[model] = nil
end

-- Nur als GPS-Label gelten, wenn Name passt ODER explizit /s im Text ist
local function isTargetLabel(inst)
	if not inst:IsA("TextLabel") then return false end
	local nm = lower(inst.Name)
	for _,cand in ipairs(CFG.LabelNameAny) do
		if nm == lower(cand) then return true end
	end
	local t = lower(inst.Text or "")
	if t:find("/%s*s") or t:find("per%s*second") or t:find("per%s*sekunde") or t:find("pro%s*sekunde") then
		return true
	end
	return false
end

local function registerLabel(label)
	if not alive then return end
	if not isTargetLabel(label) then return end

	-- Plot muss existieren (sonst ignorieren bis DescendantAdded erneut feuert)
	if not findPlotRootDynamic(label) then
		return
	end

	local model, overhead = findModelAndOverhead(label)
	if not model then return end
	if labelToModel[label] then return end
	if espTracked[model] then deregister(model) end

	local data = {
		label = label,
		value = parsePerSecond(label.Text),
		overhead = overhead,
	}

	data.connText = label:GetPropertyChangedSignal("Text"):Connect(function()
		data.value = parsePerSecond(label.Text)
		if enabled then
			if currentTopModel == model then
				setBillboard(getAdorneeFor(model, data.overhead), resolveName(model, data.overhead), data.value)
			end
			updateTop()
		end
	end)

	data.connLblAnc = label.AncestryChanged:Connect(function()
		-- deregistriere, wenn der Label nicht mehr unter einem Plot hängt
		if not findPlotRootDynamic(label) then
			deregister(model)
			if enabled then updateTop() end
		end
	end)

	data.connModelAnc = model.AncestryChanged:Connect(function()
		if not findPlotRootDynamic(model) then
			deregister(model)
			if enabled then updateTop() end
		end
	end)

	espTracked[model] = data
	labelToModel[label] = model
	if enabled then updateTop() end
end

-- Workspace-weit scannen (damit es auch funktioniert, wenn du im Ladebildschirm executest)
for _,inst in ipairs(WORLD:GetDescendants()) do
	if inst:IsA("TextLabel") then
		registerLabel(inst)
	end
end

-- Live hooks (auf workspace, nicht nur auf "Plots")
local connAdded = WORLD.DescendantAdded:Connect(function(inst)
	if not alive then return end
	if inst:IsA("TextLabel") then
		registerLabel(inst)
	end
end)

local connRemoving = WORLD.DescendantRemoving:Connect(function(inst)
	if not alive then return end
	if labelToModel[inst] then
		local m = labelToModel[inst]
		deregister(m)
		if enabled then updateTop() end
	elseif inst:IsA("Model") and espTracked[inst] then
		deregister(inst)
		if enabled then updateTop() end
	end
end)

-- Name-Refresh-Loop (holt Name nach, wenn Owner/Values später replizieren)
nameRefreshConn = RunService.Heartbeat:Connect(function(dt)
	if not enabled or not currentTopModel then return end
	nameRefreshAccum += dt
	if nameRefreshAccum < (CFG.NameRefreshInterval or 0.5) then return end
	nameRefreshAccum = 0

	local d = espTracked[currentTopModel]
	if not d then return end
	local ad = getAdorneeFor(currentTopModel, d.overhead)
	local nameText = resolveName(currentTopModel, d.overhead)
	setBillboard(ad, nameText, d.value)
end)

-- Hotkeys: F6 toggeln, Shift+F6 unload
UIS.InputBegan:Connect(function(input, gp)
	if gp or not alive then return end
	if input.KeyCode == CFG.HotkeyToggle then
		local shiftDown = UIS:IsKeyDown(Enum.KeyCode.LeftShift) or UIS:IsKeyDown(Enum.KeyCode.RightShift)
		if shiftDown then
			alive = false
			enabled = false
			if connAdded then connAdded:Disconnect() end
			if connRemoving then connRemoving:Disconnect() end
			if nameRefreshConn then nameRefreshConn:Disconnect() end
			for m,_ in pairs(espTracked) do deregister(m) end
			espTracked = {}; labelToModel = {}
			stopBeamFollowLoop()
			if beam then pcall(function() beam:Destroy() end) end
			if a0 then pcall(function() a0:Destroy() end) end
			if a1 then pcall(function() a1:Destroy() end) end
			if anchorPart then pcall(function() anchorPart:Destroy() end) end
			highlight:Destroy()
			billboardHolder:Destroy()
		else
			enabled = not enabled
			if not enabled then
				highlight.Enabled = false
				billboardHolder.Enabled = false
				setBeamTarget(nil)
			else
				updateTop()
			end
		end
	end
end)

-- Initial safety
task.delay(0.3, function()
	if alive and enabled then updateTop() end
	ensureCharacterAttachment()
	ensureBeamObjects()
end)
